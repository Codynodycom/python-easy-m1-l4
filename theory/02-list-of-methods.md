# Полный список методов строк с примерами

За строку мы возьмём переменную `str`

## str.capitalize()¶

Возвращает копию строки, переводя первую буквы в верхний регистр, а остальные в нижний.

```python
'нАЧАТЬ С ЗАГЛАВНОЙ '.capitalize()  # Начать с заглавной
```

## str.casefold()

Возвращает копию строки в сложенном регистре.
Преобразование в сложенный регистр похоже на преобразование к нижнему регистру, однако более агрессивно. Например: буква `«ß»` в нижнем регистре в немецком языке соответствует сочетанию «ss», однако, ввиду того, что символ `«ß»` уже имеет нижний регистр, метод `.lower()` ни к чему не приведёт, в то время как `casefold()` приведёт символ к `«ss»`.

```python
'ß'.lower()  # 'ß'
'ß'.casefold()  # 'ss'
'groß'.casefold() == 'gross'  # True
```

## str.center(width, fillchar)

Позиционирует по центру указанную строку, дополняя её справа и слева до указанной длины указанным символом.

  - `width`: Желаемая минимальная длина результирующей строки.
  - `fillchar`: Символ, которым следует расширять строку. По умолчанию — пробел.

Изначальная строка не обрезается, даже если в ней меньше символов, чем указано в параметре желаемой длины.

```python
''.center(3, 'w')  # www
'1'.center(2, 'w')  # 1w
'1'.center(4, 'w')  # w1ww
'1'.center(0, 'w')  # 1
'1'.center(4)  # ' 1  '
```

Символ добавляется к строке циклично сначала справа, затем слева.
Чтобы позиционировать строку вправо используйте `str.rjust()`. 

Чтобы позиционировать строку влево используйте `str.ljust()`.

## str.count(sub, start, end)

Для строки возвращает количество непересекающихся вхождений в неё указанной подстроки.

`sub`: Подстрока, количество вхождений которой следует вычислить.

`start=0`: Позиция в строке, с которой следует начать вычислять количество вхождений подстроки.

`end=None`: Позиция в строке, на которой следует завершить вычислять количество вхождений подстроки.

```python
my_str = 'подстрока из строк'
my_str.count('строка')  # 1
my_str.count('стр')  # 2
my_str.count('стр', 0, -1)  # 2
my_str.count('стр', 8)  # 1
my_str.count('стр', 1, 5)  # 0
my_str.count('стр', 1, 6)  # 1
```

Позиции начала и конца трактуются также как в срезах.

## str.encode(encoding=»utf-8», errors=»strict»)

Кодирует строку в байты/байтстроку, используя зарегистрированный кодек.

encoding: Название кодировки. По умолчанию — системная кодировка, доступная из `sys.getdefaultencoding()`.

`errors=strict`: Наименование схемы обработки ошибок. По умолчанию — `strict`.

Имена доступных кодировок лучше всего узнавать из документации к модулю `codecs`.

```python
from sys import getdefaultencoding
getdefaultencoding()  # utf-8
my_string = 'кот cat'
type(my_string)  # str
my_string.encode()
# b'\xd0\xba\xd0\xbe\xd1\x82 cat'
my_string.encode('ascii')
# UnicodeDecodeError
my_string.encode('ascii', errors='ignore')
# b' cat'
my_string.encode('ascii', errors='replace')  
# b'??? cat'
my_string.encode('ascii', errors='xmlcharrefreplace')
# b'кот cat'
my_string.encode('ascii', errors='backslashreplace')
# b'\\u043a\\u043e\\u0442 cat'
my_string.encode('ascii', errors='namereplace')
# b'\\N{CYRILLIC SMALL LETTER KA}\\N{CYRILLIC SMALL LETTER O}\\N{CYRILLIC SMALL LETTER TE} cat'
surrogated = '\udcd0\udcba\udcd0\udcbe\udcd1\udc82 cat'
surrogated.encode()  
# UnicodeEncodeError
surrogated.encode(errors='surrogateescape')
# b'\xd0\xba\xd0\xbe\xd1\x82 cat'
surrogated.encode(errors='surrogatepass')
# b'\xed\xb3\x90\xed\xb2\xba\xed\xb3\x90\xed\xb2\xbe\xed\xb3\x91\xed\xb2\x82 cat'
```

Зарегистрировать новую схему можно при помощи `codecs.register_error()`.

## str.endswith(suffix, start, end)

Возвращает флаг, указывающий на то, заканчивается ли строка указанным постфиксом.

`suffix`: Строка-постфикс, в наличии которой требуется удостовериться.

`start`: Позиция (индекс символа), с которой следует начать поиск. Поддерживает отрицательные значения.

end: Позиция (индекс символа), на которой следует завершить поиск. Поддерживает отрицательные значения.

```python
my_str = 'Discworld'
my_str.endswith('jockey')  # False
my_str.endswith('world')  # True
my_str.endswith('jockey', 2)  # False
my_str.endswith('Disc', 0, 4)  # True
```

## str.expandtabs(tabsize=8)

Возвращает копию строки, в которой символы табуляций заменены пробелами.

`tabsize=8` : Максимальное количество пробелов на которое может быть заменена табуляция.

В возвращаемой копии строки все табуляции заменяются одним или несколькими пробелами, в зависимости от текущего номера столбца и указанного максимального размера табуляции.

```python
my_str = '\t1\t10\t100\t1000\t10000'
my_str.expandtabs()
# '        1       10      100     1000    10000'
my_str.expandtabs(4)
# '    1   10  100 1000    10000'
```

Для замены табуляций изначально номер столбца задаётся равным нулю и начинается посимвольный проход по строке.

Если очередной символ является табуляцией (`\t`), то на его место вставляется столько пробелов, сколько требуется для того, что текущий номер столбца стал равным позиции следующей табуляции. При этом сам символ табуляции не копируется.

Если очередной символ является переносом строки (`\n`) или возвратом каретки (`\r`), он копируется, а текущий номер столбца задаётся равным нулю.

Другие символы копируются в неизменном виде, а текущий номер столбца увеличивается на единицу (вне зависимости от того, как символ будет представлен при выводе).

## str.find(sub, start, end)

Возвращает наименьший индекс, по которому обнаруживается начало указанной подстроки в исходной.

`sub`: Подстрока, начальный индекс размещения которой требуется определить.

`мstart=0`: Индекс начала среза в исходной строке, в котором требуется отыскать подстроку.

`end=None`: Индекс конца среза в исходной строке, в котором требуется отыскать подстроку.

Если подстрока не найдена, возвращает `−1`.

```python
my_str = 'barbarian'
my_str.find('bar')  # 0
my_str.find('bar', 1)  # 3
my_str
.find('bar', 1, 2)  # -1
```

Необязательные параметры `start` и `end` могут принимать любые значения, поддерживаемые механизмом срезов, а значит и отрицательные.

Метод должен использоваться только в случае необходимости найти индекс начала подстроки. Для обычного определения вхождения подстроки используйте оператор `in`:

```python
my_str = 'barbarian'
'bar' in my_str  # True
```

## str.format(args, *kwargs)

Возвращает копию строки, отформатированную указанным образом.

`args`: Позиционные аргументы.

`kwargs`: Именованные аргументы.

Строка, для которой вызывается данный метод может содержать как обычный текст, так и маркеры в фигурных скобках {}, которые следует заменить. Обычный текст, вне скобок будет выведен как есть без именений. Метод возвращает копию строки, в которой маркеры заменены текстовыми значениями из соответствующих аргументов. Наименование состоит из имени аргумента (либо его индекса). Числовой индекс при этом указывает на позиционный аргумент; имя указывает на именованный аргумент.

Если используются числа, и они составляют последовательность `(0, 1, 2…)`, то они могут быть опущены разом (но не выборочно). Например, `{}-{}-{} и {0}-{1}-{2}` эквивалентны.

```python
'{}-{}-{}'.format(1, 2, 3)  # Результат: '1-2-3'
'{}-{}-{}'.format(*[1, 2, 3])  # Результат: '1-2-3'
'{one}-{two}-{three}'.format(two=2, one=1, three=3)  # Результат: '1-2-3'
'{one}-{two}-{three}'.format(**{'two': 2, 'one': 1, 'three': 3})  # Результат: '1-2-3'
```

После наименования может следовать любое количество выражений доступа к атрибуту или адресации по индексу.

```python
Атрибут объекта адресуется при помощи . (точки).
Доступ к элементу при помощи [] (квадратных скобок).
```

```python
import datetime
obj = {'one': {'sub': 1}, 'two': [10, 2, 30], 'three': datetime.datetime.now()}
'{one[sub]}-{two[1]}-{three.year}'.format(**obj)
```
Приведение используется для приведения типов перед форматированием.

Обычно возврат отформатированого значения возлагается на метод `__format__()`, однако бывают случаи, что требуется произвести принудительное приведение, например, к строке, в обход имеющейся реализации. Логика форматирования по умолчанию обходится при помощи приведения значения к строке перед вызовом `__format__()`.

Поддерживаются три флага приведения: 

`* !s` Вызывает `str()`

`* !r` Вызывает `repr()` 

`* !a` Вызывает `ascii()`.

```python
import datetime 
demo = datetime.date.today()
result = '{!s}, {!r}, {!a}, {}'.format(demo, demo ,demo, demo)
print(result)
```

Формат содержит определение того как должно быть представлено значение, включая информацию о длине, выравнивании, дополнении строки, точности для чисел и тому подобное.

Можно задавать ширину поля и выравнивание

```python
right = 'Начало{0:20}Конец'.format(7)
left = 'Начало{0:<20}Конец'.format(8)
center = 'Начало{0:^20}Конец'.format(9)
print(right)
print(left)
print(center)
```

### Результат
```python
Начало                   7Конец
Начало8                   Конец
Начало                   9Конец
```

### Вывод вещественных чисел

```python
print('{0}'.format(4/3))
print('{0:f}'.format(4/3))
print('{0:.2f}'.format(4/3))
print('{0:10.3f}'.format(4/3))
```

### Результат

```python
1.3333333333333333
1.333333
1.33
1.333
```

## str.index(sub, start, end)

Возвращает наименьший индекс, по которому обнаруживается начало указанной подстроки в исходной.

`sub`: Подстрока, начальный индекс размещения которой требуется определить.

`start=0`: Индекс начала среза в исходной строке, в котором требуется отыскать подстроку.

`end=None`: Индекс конца среза исходной строке, в котором требуется отыскать подстроку.

Работа данного метода аналогична работе `str.find()`, однако, если подстрока не найдена, возбуждается исключение

```python
my_str = 'barbarian'
my_str.index('bar')  # 0
my_str.index('bar', 1)  # 3
my_str.index('bar', 1, 2)  # ValueError
```

Необязательные параметры `start` и `end` могут принимать любые значения, поддерживаемые механизмом срезов, а значит и отрицательные.

Метод должен использоваться только в случае необходимости найти индекс начала подстроки. Для обычного определения вхождения подстроки используйте оператор `in`:

```python
my_str = 'barbarian'
'bar' in my_str  # True
```

## str.isalnum()

Возвращает флаг, указывающий на то, содержит ли строка только цифры и/или буквы.

Вернёт True, если в строке хотя бы один символ и все символы строки являются цифрами и/или буквами, иначе — `False`.

```python
''.isalnum()  # False
'  '.isalnum()  # False
'!@#'.isalnum()  # False
'abc'.isalnum()  # True
'123'.isalnum()  # True
'abc123'.isalnum()  # True
```

## str.isalpha()

Возвращает флаг, указывающий на то, содержит ли строка только буквы.

Вернёт True, если в строке есть хотя бы один символ, и все символы строки являются буквами, иначе — `False`.

```python
''.isalpha()  # False
'  '.isalpha()  # False
'!@#'.isalpha()  # False
'abc'.isalpha()  # True
'123'.isalpha()  # False
'abc123'.isalpha()  # False
```

## str.isascii()

Возвращает флаг, указывающий на то, содержит ли строка только ASCII-символы.

Вернет True, если в строке содержаться только ASCII-символы или строка пустая, иначе вернет `False`.

## str.isdigit()

Возвращает флаг, указывающий на то, содержит ли строка только цифры. Вернёт True, если в строке хотя бы один символ и все символы строки являются цифрами, иначе — `False`.

```python
''.isdigit()  # False
'  '.isdigit()  # False
'!@#'.isdigit()  # False
'abc'.isdigit()  # False
'123'.isdigit()  # True
'abc123'.isdigit()  # False
```

## str.isidentifier()

Возвращает флаг, указывающий на то, является ли строка идентификатором.

Речь идёт об идентификаторах языка. Более подробная информация об идентификаторах и ключевых словах Питона содержится в разделе оригинальной документации `Identifiers` and `keywords`.

```python
'continue'.isidentifier()  # True
'cat'.isidentifier()  # True
'function_name'.isidentifier()  # True
'ClassName'.isidentifier()  # True
'_'.isidentifier()  # True
'number1'.isidentifier()  # True
'1st'.isidentifier()  # False
'*'.isidentifier()  # False
```

Для проверки на то является ли строка зарезервированным идентификатором (например: `def`, `class`), используйте `keyword.iskeyword()`.

## str.islower()

Возвращает флаг, указывающий на то, содержит ли строка символы только нижнего регистра. Вернёт `True`, если все символы строки поддерживающие приведение к регистру приведены к нижнему, иначе — `False`.

```python
'нижний lower'.islower()  # True
```

## Внимание

`str.islower()` может возвращать `False`, например, если строка содержит только символы не поддерживающие приведение к регистру:

```python
'12'.islower()  # False
```

Для приведения символов строки к нижнему регистру используйте метод `lower()`.

## str.isnumeric()

Возвращает флаг, указывающий на то, содержит ли строка только числа.

Вернёт True, если в строке есть символы и все они присущи числам.

```python
''.isnumeric()  # False
'a'.isnumeric()  # False
'0'.isnumeric()  # True
'10'.isnumeric()  # True
'⅓'.isnumeric()  # True
'Ⅻ'.isnumeric()  # True
```

К символам чисел относятся цифры, а также все символы, имеющие признак числа в Unicode, например: U+2155 (VULGAR FRACTION ONE FIFTH)— это любые символы, у которых признак `Numeric_Type` установлен равным `Digit`, или `Decimal`, или `Numeric`.

## str.isprintable()

Возвращает флаг, указывающий на то, все ли символы строки являются печатаемыми. Вернёт `True`, если строка пустая, либо если все её символы могут быть выведены на печать.

```python
''.isprintable()  # True
' '.isprintable()  # True
'1'.isprintable()  # True
'a'.isprintable()  # True
''.isprintable()  # False (Group Separator)
''.isprintable()  # False (Escape)
```

Непечатаемыми символами являются символы Юникод из категории Other или Separator, исключая символ пробела из ASCII, который считается печатаемым. 

Печатаемые символы не требуется экранировать в случае применения `repr()` к строке. Они не влияют на обработку строк, отправляемых в `sys.stdout` или `sys.stderr`.

## str.isspace()

Возвращает флаг, указывающий на то, содержит ли строка только пробельные символы. Вернёт `True`, если в строке есть символы и все они являются пробельными, иначе — `False`.

```python
'  '.isspace()  # True
'\n'.isspace()  # True
'\t'.isspace()  # True
' '.isspace()  # True (OGHAM SPACE MARK)
''.isspace()  # False
'!@#'.isspace()  # False
'abc'.isspace()  # False
'123'.isspace()  # False
'abc123'.isspace()  # False
```

Пробельными символами являются символы Юникод изкатегории Other или Separator, а также те, у которых свойство бинаправленности принимает значение `WS`, `B`, или `S`.

## str.istitle()

Возвращает флаг, указывающий на то, начинается ли каждое из «слов» строки с заглавной буквы.

Вернёт `True`, если в строке хотя бы один символ или все «слова» в строке начинаются с заглавных букв, иначе — `False`.

```python
'S'.istitle()  # True
'Some Text'.istitle()  # True
'Some text'.istitle()  # False
'S1 T2%'.istitle()  # True
```

## str.isupper()

Возвращает флаг, указывающий на то, содержит ли строка символы только верхнего регистра. Вернёт `True`, если все символы строки поддерживающие приведение к регистру приведены к верхнему, иначе — `False`.

## str.join(iterable)

Возвращает строку, собранную изэлементов указанного объекта, поддерживающего итерирование.

`iterable`: Объект со строками, поддерживающий итерирование.

В качестве соединительного элемента между указанными используется объект строки, предоставляющий данный метод.

```python
dots = '..'
my_str = dots.join(['1', '2'])  # '1..2'
my_str = dots.join('ab')  # 'a..b'
```

Ожидается, что итерируемый объект выдаёт строки. Для массового приведения к строке можно воспользоваться функцией `map()`:

```python
dots.join(map(str, 100, 200))
# '100…200'
```

## str.ljust(width, fillchar)

Позиционирует влево указанную строку, дополняя её справа до указанной длины указанным символом.

`width`: Желаемая минимальная длина результирующей строки.

`fillchar`: Символ, которым следует расширять строку. По умолчанию — пробел.

Изначальная строка не обрезается, даже если в ней меньше символов, чем указано в параметре желаемой длины.

```python
''.ljust(3, 'w')  # www
'1'.ljust(4, 'w')  # 1www
'1'.ljust(0, 'w')  # 1
'1'.ljust(4)  # '1   '
```

Антонимом функции, позиционирующим строку вправо, является `str.rjust()`. Для расширения строки в обоих направлениях используйте `str.center()`.

## str.lower()

Возвращает копию исходной строки с символами приведёнными к нижнему регистру. Алгоритм приведения к нижнему регистру описан в параграфе 3.13 стандарта Unicode.

```python
'SoMe СлОнов'.lower()  # some слонов'
```

Для приведения символов строки к верхнему регистру используйте метод `upper()`. Для проверки того, содержит ли строка только символы в нижнем регистре используйте `islower()`.

`str.lower().islower()` может возвращать `False`, если строка содержит только символы не поддерживающие приведение к регистру:

```python
'12'.lower().islower() # False
```

## str.lstrip(chars)

Возвращает копию указанной строки, с начала (слева l — left) которой устранены указанные символы.

`chars=None`: Строка с символами, которые требуется устранить. 

Если не указана, будут устранены пробельные символы. Это не префикс и не суффикс, это перечисление нужных символов.

```python
'abca'.lstrip('ac')  # 'bca'
```

## str.maketrans(x, y, z)

Возвращает таблицу переводов, которую можно использовать в методе `translate`. В примере ниже букве «а» будет соответствовать `«1»`, `«b» — «2»`, а `«с» — «3»`

```python
intab = "abc" 
outtab = "123" 
trantab = str.maketrans(intab, outtab) 
```

## str.partition(sep)

Разбивает строку на три составляющие (начало, разделитель, конец) и возвращает в виде кортежа. Направление разбиения: слева направо.

`sep`: Строка-разделитель, при помощи которой требуется разбить исходную строку. Может содержать как один, так и несколько символов.

Возвращает кортеж из трёх элементов.

```python
my_str = ''
my_str.partition('.')  # ('', '', '')
my_str = '12'
my_str.partition('.')  # ('12', '', '')
my_str = '.1.2'
my_str.partition('.')  # ('', '.', '1.2')
```

В случаях, когда требуется, чтобы разбиение строки происходило справа налево, используйте `str.rpartition`.

## str.replace(old, new, count)

Возвращает копию строки, в которой заменены все вхождения указанной строки указанным значением.

`old`: Искомая подстрока, которую следует заменить.

`new`: Подстрока, на которую следует заменить искомую.

`maxcount=None`: Максимальное требуемое количество замен. Если не указано, будут заменены все вхождения искомой строки.

```python
my_str = 'barbarian'
my_str = my_str.replace('bar', 'mur')  # 'murmurian'
my_str = my_str.replace('mur', 'bur', 1)  # 'burmurian'
```

## str.rfind(sub, start, end)

Возвращают индексы последнего вхождения искомой подстроки. Если же подстрока не найдена, то метод возвращает значение −1.

## str.rindex(sub, start, end)

Возвращает наибольший индекс, по которому обнаруживается конец указанной подстроки в исходной.

`sub`: Подстрока, начальный индекс размещения которой требуется определить.

`start=0`: Индекс начала среза в исходной строке, в котором требуется отыскать подстроку.

`end=None`: Индекс конца среза в исходной строке, в котором требуется отыскать подстроку.

Работа данного метода аналогична работе `str.rfind()`, однако, если подстрока не найдена, возбуждается исключение

```python
my_str = 'barbarian'
my_str.rindex('bar')  # 3
my_str.rindex('bar', 1)  # 3
my_str.rindex('bar', 1, 2)  # ValueError
```

Необязательные параметры `start` и `end` могут принимать любые значения, поддерживаемые механизмом срезов, а значит и отрицательные.

## str.rjust(width, fillchar)

Позиционирует вправо указанную строку, дополняя её слева до указанной длины указанным символом.

`width`: Желаемая минимальная длина результирующей строки.

`fillchar`: Символ, которым следует расширять строку. По умолчанию — пробел.

Изначальная строка не обрезается, даже если в ней меньше символов, чем указано в параметре желаемой длины.

```python
''.rjust(3, 'w')  # www
'1'.rjust(4, 'w')  # www1
'1'.rjust(0, 'w')  # 1
'1'.rjust(4)  # '   1'
```

Антонимом функции, позиционирующим строку влево, является `str.ljust()`. Для расширения строки в обоих направлениях используйте `str.center()`. Когда требуется дополнить строку нулями слева, используйте `str.zfill()`.

## str.rpartition(sep)

Разбивает строку на три составляющие (начало, разделитель, конец) и возвращает в виде кортежа. Направление разбиения: справа налево.

`sep`: Строка-разделитель, при помощи которой требуется разбить исходную строку. Может содержать как один, так и несколько символов. Возвращает кортеж из трёх элементов.

Поведение метода аналогично поведению `str.partition` за исключением направления разбиения строки.

```python
my_str = ''
my_str.rpartition('.')  # ('', '', '')
my_str = '12'
my_str.rpartition('.')  # ('', '', '12')
my_str = '.1.2'
my_str.rpartition('.')  # ('.1', '.', '2')
```

## str.rsplit(sep=None, maxsplit=-1)

Разбивает строку на части, используя разделитель, и возвращает эти части списком. Направление разбиения: справа налево.

`sep=None`: Строка-разделитель, при помощи которой требуется разбить исходную строку. Может содержать как один, так и несколько символов. 

Если не указан, то используется специальный алгоритм разбиения, для которого разделителем считается последовательность пробельных символов.

`maxsplit=-1`: Максимальное количество разбиений, которое требуется выполнить. Если −1, то количество разбиений не ограничено.

Поведение метода аналогично поведению `str.split` за исключением направления разбиения строки.

## str.rstrip(chars)

Возвращает копию указанной строки, с конца (справа r — right) которой устранены указанные символы.

`chars=None`: Строка с символами, которые требуется устранить. 

Если не указана, будут устранены пробельные символы. Это не префикс и не суффикс, это перечисление нужных символов.

```python
'abca'.rstrip('ac')  # 'ab'
```

Когда требуется разбить строку на три составляющие (начало, разделитель, конец), используйте `str.rpartition`.

## str.split(sep=None, maxsplit=-1)

Разбивает строку на части, используя разделитель, и возвращает эти части списком. Направление разбиения: слева направо.

`sep=None`: Строка-разделитель, при помощи которой требуется разбить исходную строку. Может содержать как один, так и несколько символов. 

Если не указан, то используется специальный алгоритм разбиения, для которого разделителем считается последовательность пробельных символов.

`maxsplit=-1`: Максимальное количество разбиений, которое требуется выполнить. Если −1, то количество разбиений не ограничено.

Если указан разделитель, разбиение пустой строки вернёт список с единственным элементом — пустой строкой: ''.

```python
'1,2,3'.split(',')  # ['1', '2', '3']
'1,2,3'.split(',', maxsplit=1)  # ['1', '2,3']
'1,2,,3,'.split(',')   # ['1', '2', '', '3', ''] 
'1   2   3'.split(' ')  # ['1', '', '', '2', '', '', '3']
```

Если разделитель не указан, разбиение пустой строки вернёт пустой список:.

```python
'1 2 3'.split()  # ['1', '2', '3']
'1 2 3'.split(maxsplit=1)  # ['1', '2 3']
'1   2   3'.split()  # ['1', '2', '3']  
```

В случаях, когда требуется, чтобы разбиение строки происходило справа налево, используйте `str.rsplit`. Когда требуется разбить строку на три составляющие (начало, разделитель, конец), используйте `str.partition`.

## str.splitlines(keepends)

Разбивает строку на множество строк, возвращая их списком.

`keepends=False` — Флаг, указывающий на то следует ли оставлять в результирующем списке символы переноса строк. По умолчанию символы удаляются.

Разбиение строки на подстроки производится в местах, где встречаются символы переноса строк.

```python
my_str = 'ab c\n\nde fg\rkl\r\n'
my_str.splitlines()  # ['ab c', '', 'de fg', 'kl']
my_str.splitlines(True)  # ['ab c\n', '\n', 'de fg\r', 'kl\r\n']
```

В отличие от `split()`, которому можно передать символ-разделитель, данный метод для пустой строки вернёт пустой список, а символ переноса строки в конце не добавит в список дополнительного элемента.

```python
''.splitlines()  # []
''.split('\n')  # ['']
my_str = 'ab\n cd\n'
my_str.splitlines()  # ['ab', 'cd']
my_str.split('\n')  # ['ab', 'cd', '']
```

# str.startswith(prefix, start, end)

Возвращает флаг, указывающий на то, начинается ли строка с указанного префикса.

`prefix`: Строка-префикс, в наличии которой требуется удостовериться.

`start`: Позиция (индекс символа), с которой следует начать поиск. Поддерживает отрицательные значения.

`end`: Позиция (индекс символа), на которой следует завершить поиск. Поддерживает отрицательные значения.

```python
my_str = 'Discworld'
my_str.startswith('Mad')  # False
my_str.startswith('Disc')  # True
my_str.startswith('Disc', 1)  # False
my_str.startswith('world', 4, 9)  # True
```

Для определения наличия постфикса в строке используйте `str.endswith()`.

# str.strip(chars)

Возвращает копию указанной строки, с обоих концов которой устранены указанные символы.

`chars=None`: Строка с символами, которые требуется устранить. 

Если не указана, будут устранены пробельные символы. Это не префикс и не суффикс, это перечисление нужных символов.

```python
'abca'.strip('ac')  # 'b'
```

# str.swapcase()

Возвращает копию строки, в которой каждая буква будет иметь противоположный регистр.

В ходе смены регистра, буквы в нижнем регистре преобразуются в верхний, а буквы в верхнем преобразуются в нижний.

```python
'Кот ОбОрмот!'.swapcase()  # кОТ оБоРМОТ!
```

# Внимание

Для 8-битных строк (Юникод) результат метода зависит от локали. Следующее выражение не обязано быть истинным: `str.swapcase().swapcase()` == `str`.

# str.title()

Возвращает копию строки, в которой каждое новое слово начинается с заглавной буквы и продолжается строчными. В результирующей строке первая буква каждого нового слова становится заглавной, в то время как остальные становятся строчными. 

Такое написание характерно для заголовков в английском языке.

```python
'кот ОбОрмот!'.title()  # Кот Обормот!
"they're bill's friends from the UK".title()  
# They'Re Bill'S Friends From The Uk
```

Алгоритм использует простое, независящее от языка определение слова — это группа последовательных букв. 

Такого определения во многих случаях достаточно, однако, в словах с апострофами (в английском они используются, например, в сокращениях и притяжательных формах) оно приводит к неожиданным результатам (см. пример выше). 

И в таких случаях лучше всего будет воспользоваться методом замены врегулярных выражениях (см. модуль re).

Для 8-битных строк (Юникод) результат метода зависит от текущей локали.

# str.translate(table)

Возвращает строку, преобразованную с помощью таблицы переводов, которую в свою очередь можно получить с помощью `str.maketrans`. В примере ниже все буквы `«а»` будут заменены на `«1»`, а `«b»` — на `«2»`.

```python
trantab = str.maketrans("ab", "12")
print('abc test'.translate(trantab))
```

`##str.upper()` Возвращает копию исходной строки с символами приведёнными к верхнему регистру. Алгоритм приведения к верхнему регистру описан в параграфе 3.13 стандарта Unicode.

```python
'SoMe СлОнов'.upper()  # SOME СЛОНОВ
```

Для приведения символов строки к нижнему регистру используйте метод `lower()`. Для проверки того, содержит ли строка только символы в верхнем регистре используйте `isupper()`.

# str.zfill(width)

Дополняет указанную строку нулями слева до указанной минимальной длины.

`width`: Желаемая минимальная длина результирующей строки. 

Изначальная строка не обрезается, даже если вней меньше символов, чем указано в параметре желаемой длины. В ходе компоновки результирующей строки ведущие знаки + и - сохраняют своё место в её начале.

```python
''.zfill(3)  # 000
'1'.zfill(4)  # 0001
'1'.zfill(0)  # 1
'-1'.zfill(4)  # -001
'a'.zfill(4)  # 000a
'-a'.zfill(4)  # -00a
```

Условно сходного результата можно также добиться при использовании метода `str.rjust()`, передав 0 в качестве второго аргумента. Условным антонимом функции, добавляющим нули справа можно считать `str.ljust()`, передав 0 в качестве второго аргумента.

## Если ты всё прочитал, ты - герой!